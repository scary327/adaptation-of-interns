// node_modules/frappe-gantt/dist/frappe-gantt.min.js
var Gantt = function() {
  "use strict";
  const t = { en: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], ru: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"] };
  var e = { parse(t2, e2 = "-", s2 = /[.:]/) {
    if (t2 instanceof Date)
      return t2;
    if ("string" == typeof t2) {
      let i2, n2;
      const a2 = t2.split(" ");
      i2 = a2[0].split(e2).map((t3) => parseInt(t3, 10)), n2 = a2[1] && a2[1].split(s2), i2[1] = i2[1] - 1;
      let o2 = i2;
      return n2 && n2.length && (4 == n2.length && (n2[3] = "0." + n2[3], n2[3] = 1e3 * parseFloat(n2[3])), o2 = o2.concat(n2)), new Date(...o2);
    }
  }, to_string(t2, e2 = false) {
    if (!(t2 instanceof Date))
      throw new TypeError("Invalid argument type");
    const i2 = this.get_date_values(t2).map((t3, e3) => (1 === e3 && (t3 += 1), s(t3 + "", 6 === e3 ? 3 : 2, "0"))), n2 = `${i2[0]}-${i2[1]}-${i2[2]}`, a2 = `${i2[3]}:${i2[4]}:${i2[5]}.${i2[6]}`;
    return n2 + (e2 ? " " + a2 : "");
  }, format(e2, i2 = "YYYY-MM-DD HH:mm:ss.SSS", n2 = "en") {
    const a2 = this.get_date_values(e2).map((t2) => s(t2, 2, 0)), o2 = { YYYY: a2[0], MM: s(+a2[1] + 1, 2, 0), DD: a2[2], HH: a2[3], mm: a2[4], ss: a2[5], SSS: a2[6], D: a2[2], MMMM: t[n2][+a2[1]], MMM: t[n2][+a2[1]] };
    let r2 = i2;
    const h2 = [];
    return Object.keys(o2).sort((t2, e3) => e3.length - t2.length).forEach((t2) => {
      r2.includes(t2) && (r2 = r2.replace(t2, `$${h2.length}`), h2.push(o2[t2]));
    }), h2.forEach((t2, e3) => {
      r2 = r2.replace(`$${e3}`, t2);
    }), r2;
  }, diff(t2, e2, s2 = "day") {
    let i2, n2, a2, o2, r2, h2, d;
    return d = (h2 = (r2 = (a2 = (o2 = (n2 = (i2 = t2 - e2) / 1e3) / 60) / 60) / 24) / 30) / 12, s2.endsWith("s") || (s2 += "s"), Math.floor({ milliseconds: i2, seconds: n2, minutes: o2, hours: a2, days: r2, months: h2, years: d }[s2]);
  }, today() {
    const t2 = this.get_date_values(/* @__PURE__ */ new Date()).slice(0, 3);
    return new Date(...t2);
  }, now: () => /* @__PURE__ */ new Date(), add(t2, e2, s2) {
    e2 = parseInt(e2, 10);
    const i2 = [t2.getFullYear() + ("year" === s2 ? e2 : 0), t2.getMonth() + ("month" === s2 ? e2 : 0), t2.getDate() + ("day" === s2 ? e2 : 0), t2.getHours() + ("hour" === s2 ? e2 : 0), t2.getMinutes() + ("minute" === s2 ? e2 : 0), t2.getSeconds() + ("second" === s2 ? e2 : 0), t2.getMilliseconds() + ("millisecond" === s2 ? e2 : 0)];
    return new Date(...i2);
  }, start_of(t2, e2) {
    const s2 = { year: 6, month: 5, day: 4, hour: 3, minute: 2, second: 1, millisecond: 0 };
    function i2(t3) {
      const i3 = s2[e2];
      return s2[t3] <= i3;
    }
    const n2 = [t2.getFullYear(), i2("year") ? 0 : t2.getMonth(), i2("month") ? 1 : t2.getDate(), i2("day") ? 0 : t2.getHours(), i2("hour") ? 0 : t2.getMinutes(), i2("minute") ? 0 : t2.getSeconds(), i2("second") ? 0 : t2.getMilliseconds()];
    return new Date(...n2);
  }, clone(t2) {
    return new Date(...this.get_date_values(t2));
  }, get_date_values: (t2) => [t2.getFullYear(), t2.getMonth(), t2.getDate(), t2.getHours(), t2.getMinutes(), t2.getSeconds(), t2.getMilliseconds()], get_days_in_month(t2) {
    const e2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], s2 = t2.getMonth();
    if (1 !== s2)
      return e2[s2];
    const i2 = t2.getFullYear();
    return i2 % 4 == 0 && i2 % 100 != 0 || i2 % 400 == 0 ? 29 : 28;
  } };
  function s(t2, e2, s2) {
    return t2 += "", e2 >>= 0, s2 = String(void 0 !== s2 ? s2 : " "), t2.length > e2 ? String(t2) : ((e2 -= t2.length) > s2.length && (s2 += s2.repeat(e2 / s2.length)), s2.slice(0, e2) + String(t2));
  }
  function i(t2, e2) {
    return "string" == typeof t2 ? (e2 || document).querySelector(t2) : t2 || null;
  }
  function n(t2, e2) {
    const s2 = document.createElementNS("http://www.w3.org/2000/svg", t2);
    for (let t3 in e2)
      if ("append_to" === t3) {
        e2.append_to.appendChild(s2);
      } else
        "innerHTML" === t3 ? s2.innerHTML = e2.innerHTML : s2.setAttribute(t3, e2[t3]);
    return s2;
  }
  function a(t2, e2, s2, a2) {
    const o2 = function(t3, e3, s3, a3, o3 = "0.4s", r2 = "0.1s") {
      const h2 = t3.querySelector("animate");
      if (h2)
        return i.attr(h2, { attributeName: e3, from: s3, to: a3, dur: o3, begin: "click + " + r2 }), t3;
      const d = n("animate", { attributeName: e3, from: s3, to: a3, dur: o3, begin: r2, calcMode: "spline", values: s3 + ";" + a3, keyTimes: "0; 1", keySplines: (p = "ease-out", { ease: ".25 .1 .25 1", linear: "0 0 1 1", "ease-in": ".42 0 1 1", "ease-out": "0 0 .58 1", "ease-in-out": ".42 0 .58 1" }[p]) });
      var p;
      return t3.appendChild(d), t3;
    }(t2, e2, s2, a2);
    if (o2 === t2) {
      const t3 = document.createEvent("HTMLEvents");
      t3.initEvent("click", true, true), t3.eventName = "click", o2.dispatchEvent(t3);
    }
  }
  i.on = (t2, e2, s2, n2) => {
    n2 ? i.delegate(t2, e2, s2, n2) : (n2 = s2, i.bind(t2, e2, n2));
  }, i.off = (t2, e2, s2) => {
    t2.removeEventListener(e2, s2);
  }, i.bind = (t2, e2, s2) => {
    e2.split(/\s+/).forEach(function(e3) {
      t2.addEventListener(e3, s2);
    });
  }, i.delegate = (t2, e2, s2, i2) => {
    t2.addEventListener(e2, function(t3) {
      const e3 = t3.target.closest(s2);
      e3 && (t3.delegatedTarget = e3, i2.call(this, t3, e3));
    });
  }, i.closest = (t2, e2) => e2 ? e2.matches(t2) ? e2 : i.closest(t2, e2.parentNode) : null, i.attr = (t2, e2, s2) => {
    if (!s2 && "string" == typeof e2)
      return t2.getAttribute(e2);
    if ("object" != typeof e2)
      t2.setAttribute(e2, s2);
    else
      for (let s3 in e2)
        i.attr(t2, s3, e2[s3]);
  };
  class o {
    constructor(t2, e2) {
      this.set_defaults(t2, e2), this.prepare(), this.draw(), this.bind();
    }
    set_defaults(t2, e2) {
      this.action_completed = false, this.gantt = t2, this.task = e2;
    }
    prepare() {
      this.prepare_values(), this.prepare_helpers();
    }
    prepare_values() {
      this.invalid = this.task.invalid, this.height = this.gantt.options.bar_height, this.x = this.compute_x(), this.y = this.compute_y(), this.corner_radius = this.gantt.options.bar_corner_radius, this.duration = e.diff(this.task._end, this.task._start, "hour") / this.gantt.options.step, this.width = this.gantt.options.column_width * this.duration, this.progress_width = this.gantt.options.column_width * this.duration * (this.task.progress / 100) || 0, this.group = n("g", { class: "bar-wrapper " + (this.task.custom_class || ""), "data-id": this.task.id }), this.bar_group = n("g", { class: "bar-group", append_to: this.group }), this.handle_group = n("g", { class: "handle-group", append_to: this.group });
    }
    prepare_helpers() {
      SVGElement.prototype.getX = function() {
        return +this.getAttribute("x");
      }, SVGElement.prototype.getY = function() {
        return +this.getAttribute("y");
      }, SVGElement.prototype.getWidth = function() {
        return +this.getAttribute("width");
      }, SVGElement.prototype.getHeight = function() {
        return +this.getAttribute("height");
      }, SVGElement.prototype.getEndX = function() {
        return this.getX() + this.getWidth();
      };
    }
    draw() {
      this.draw_bar(), this.draw_progress_bar(), this.draw_label(), this.draw_resize_handles();
    }
    draw_bar() {
      this.$bar = n("rect", { x: this.x, y: this.y, width: this.width, height: this.height, rx: this.corner_radius, ry: this.corner_radius, class: "bar", append_to: this.bar_group }), a(this.$bar, "width", 0, this.width), this.invalid && this.$bar.classList.add("bar-invalid");
    }
    draw_progress_bar() {
      this.invalid || (this.$bar_progress = n("rect", { x: this.x, y: this.y, width: this.progress_width, height: this.height, rx: this.corner_radius, ry: this.corner_radius, class: "bar-progress", append_to: this.bar_group }), a(this.$bar_progress, "width", 0, this.progress_width));
    }
    draw_label() {
      n("text", { x: this.x + this.width / 2, y: this.y + this.height / 2, innerHTML: this.task.name, class: "bar-label", append_to: this.bar_group }), requestAnimationFrame(() => this.update_label_position());
    }
    draw_resize_handles() {
      if (this.invalid)
        return;
      const t2 = this.$bar;
      n("rect", { x: t2.getX() + t2.getWidth() - 9, y: t2.getY() + 1, width: 8, height: this.height - 2, rx: this.corner_radius, ry: this.corner_radius, class: "handle right", append_to: this.handle_group }), n("rect", { x: t2.getX() + 1, y: t2.getY() + 1, width: 8, height: this.height - 2, rx: this.corner_radius, ry: this.corner_radius, class: "handle left", append_to: this.handle_group }), this.task.progress && this.task.progress < 100 && (this.$handle_progress = n("polygon", { points: this.get_progress_polygon_points().join(","), class: "handle progress", append_to: this.handle_group }));
    }
    get_progress_polygon_points() {
      const t2 = this.$bar_progress;
      return [t2.getEndX() - 5, t2.getY() + t2.getHeight(), t2.getEndX() + 5, t2.getY() + t2.getHeight(), t2.getEndX(), t2.getY() + t2.getHeight() - 8.66];
    }
    bind() {
      this.invalid || this.setup_click_event();
    }
    setup_click_event() {
      i.on(this.group, "focus " + this.gantt.options.popup_trigger, (t2) => {
        this.action_completed || ("click" === t2.type && this.gantt.trigger_event("click", [this.task]), this.gantt.unselect_all(), this.group.classList.toggle("active"), this.show_popup());
      });
    }
    show_popup() {
      if (this.gantt.bar_being_dragged)
        return;
      const t2 = e.format(this.task._start, "MMM D") + " - " + e.format(e.add(this.task._end, -1, "second"), "MMM D");
      this.gantt.show_popup({ target_element: this.$bar, title: this.task.name, subtitle: t2, task: this.task });
    }
    update_bar_position({ x: t2 = null, width: e2 = null }) {
      const s2 = this.$bar;
      if (t2) {
        if (!this.task.dependencies.map((t3) => this.gantt.get_bar(t3).$bar.getX()).reduce((e3, s3) => t2 >= s3, t2))
          return void (e2 = null);
        this.update_attr(s2, "x", t2);
      }
      e2 && e2 >= this.gantt.options.column_width && this.update_attr(s2, "width", e2), this.update_label_position(), this.update_handle_position(), this.update_progressbar_position(), this.update_arrow_position();
    }
    date_changed() {
      let t2 = false;
      const { new_start_date: s2, new_end_date: i2 } = this.compute_start_end_date();
      Number(this.task._start) !== Number(s2) && (t2 = true, this.task._start = s2), Number(this.task._end) !== Number(i2) && (t2 = true, this.task._end = i2), t2 && this.gantt.trigger_event("date_change", [this.task, s2, e.add(i2, -1, "second")]);
    }
    progress_changed() {
      const t2 = this.compute_progress();
      this.task.progress = t2, this.gantt.trigger_event("progress_change", [this.task, t2]);
    }
    set_action_completed() {
      this.action_completed = true, setTimeout(() => this.action_completed = false, 1e3);
    }
    compute_start_end_date() {
      const t2 = this.$bar, s2 = t2.getX() / this.gantt.options.column_width, i2 = e.add(this.gantt.gantt_start, s2 * this.gantt.options.step, "hour"), n2 = t2.getWidth() / this.gantt.options.column_width;
      return { new_start_date: i2, new_end_date: e.add(i2, n2 * this.gantt.options.step, "hour") };
    }
    compute_progress() {
      const t2 = this.$bar_progress.getWidth() / this.$bar.getWidth() * 100;
      return parseInt(t2, 10);
    }
    compute_x() {
      const { step: t2, column_width: s2 } = this.gantt.options, i2 = this.task._start, n2 = this.gantt.gantt_start;
      let a2 = e.diff(i2, n2, "hour") / t2 * s2;
      if (this.gantt.view_is("Month")) {
        a2 = e.diff(i2, n2, "day") * s2 / 30;
      }
      return a2;
    }
    compute_y() {
      return this.gantt.options.header_height + this.gantt.options.padding + this.task._index * (this.height + this.gantt.options.padding);
    }
    get_snap_position(t2) {
      let e2, s2, i2 = t2;
      return s2 = this.gantt.view_is("Week") ? i2 - (e2 = t2 % (this.gantt.options.column_width / 7)) + (e2 < this.gantt.options.column_width / 14 ? 0 : this.gantt.options.column_width / 7) : this.gantt.view_is("Month") ? i2 - (e2 = t2 % (this.gantt.options.column_width / 30)) + (e2 < this.gantt.options.column_width / 60 ? 0 : this.gantt.options.column_width / 30) : i2 - (e2 = t2 % this.gantt.options.column_width) + (e2 < this.gantt.options.column_width / 2 ? 0 : this.gantt.options.column_width);
    }
    update_attr(t2, e2, s2) {
      return s2 = +s2, isNaN(s2) || t2.setAttribute(e2, s2), t2;
    }
    update_progressbar_position() {
      this.$bar_progress.setAttribute("x", this.$bar.getX()), this.$bar_progress.setAttribute("width", this.$bar.getWidth() * (this.task.progress / 100));
    }
    update_label_position() {
      const t2 = this.$bar, e2 = this.group.querySelector(".bar-label");
      e2.getBBox().width > t2.getWidth() ? (e2.classList.add("big"), e2.setAttribute("x", t2.getX() + t2.getWidth() + 5)) : (e2.classList.remove("big"), e2.setAttribute("x", t2.getX() + t2.getWidth() / 2));
    }
    update_handle_position() {
      const t2 = this.$bar;
      this.handle_group.querySelector(".handle.left").setAttribute("x", t2.getX() + 1), this.handle_group.querySelector(".handle.right").setAttribute("x", t2.getEndX() - 9);
      const e2 = this.group.querySelector(".handle.progress");
      e2 && e2.setAttribute("points", this.get_progress_polygon_points());
    }
    update_arrow_position() {
      this.arrows = this.arrows || [];
      for (let t2 of this.arrows)
        t2.update();
    }
  }
  class r {
    constructor(t2, e2, s2) {
      this.gantt = t2, this.from_task = e2, this.to_task = s2, this.calculate_path(), this.draw();
    }
    calculate_path() {
      let t2 = this.from_task.$bar.getX() + this.from_task.$bar.getWidth() / 2;
      const e2 = () => this.to_task.$bar.getX() < t2 + this.gantt.options.padding && t2 > this.from_task.$bar.getX() + this.gantt.options.padding;
      for (; e2(); )
        t2 -= 10;
      const s2 = this.gantt.options.header_height + this.gantt.options.bar_height + (this.gantt.options.padding + this.gantt.options.bar_height) * this.from_task.task._index + this.gantt.options.padding, i2 = this.to_task.$bar.getX() - this.gantt.options.padding / 2, n2 = this.gantt.options.header_height + this.gantt.options.bar_height / 2 + (this.gantt.options.padding + this.gantt.options.bar_height) * this.to_task.task._index + this.gantt.options.padding, a2 = this.from_task.task._index > this.to_task.task._index, o2 = this.gantt.options.arrow_curve, r2 = a2 ? 1 : 0, h2 = a2 ? -o2 : o2, d = a2 ? n2 + this.gantt.options.arrow_curve : n2 - this.gantt.options.arrow_curve;
      if (this.path = `
            M ${t2} ${s2}
            V ${d}
            a ${o2} ${o2} 0 0 ${r2} ${o2} ${h2}
            L ${i2} ${n2}
            m -5 -5
            l 5 5
            l -5 5`, this.to_task.$bar.getX() < this.from_task.$bar.getX() + this.gantt.options.padding) {
        const e3 = this.gantt.options.padding / 2 - o2, a3 = this.to_task.$bar.getY() + this.to_task.$bar.getHeight() / 2 - h2, d2 = this.to_task.$bar.getX() - this.gantt.options.padding;
        this.path = `
                M ${t2} ${s2}
                v ${e3}
                a ${o2} ${o2} 0 0 1 -${o2} ${o2}
                H ${d2}
                a ${o2} ${o2} 0 0 ${r2} -${o2} ${h2}
                V ${a3}
                a ${o2} ${o2} 0 0 ${r2} ${o2} ${h2}
                L ${i2} ${n2}
                m -5 -5
                l 5 5
                l -5 5`;
      }
    }
    draw() {
      this.element = n("path", { d: this.path, "data-from": this.from_task.task.id, "data-to": this.to_task.task.id });
    }
    update() {
      this.calculate_path(), this.element.setAttribute("d", this.path);
    }
  }
  class h {
    constructor(t2, e2) {
      this.parent = t2, this.custom_html = e2, this.make();
    }
    make() {
      this.parent.innerHTML = '\n            <div class="title"></div>\n            <div class="subtitle"></div>\n            <div class="pointer"></div>\n        ', this.hide(), this.title = this.parent.querySelector(".title"), this.subtitle = this.parent.querySelector(".subtitle"), this.pointer = this.parent.querySelector(".pointer");
    }
    show(t2) {
      if (!t2.target_element)
        throw new Error("target_element is required to show popup");
      t2.position || (t2.position = "left");
      const e2 = t2.target_element;
      if (this.custom_html) {
        let e3 = this.custom_html(t2.task);
        e3 += '<div class="pointer"></div>', this.parent.innerHTML = e3, this.pointer = this.parent.querySelector(".pointer");
      } else
        this.title.innerHTML = t2.title, this.subtitle.innerHTML = t2.subtitle, this.parent.style.width = this.parent.clientWidth + "px";
      let s2;
      e2 instanceof HTMLElement ? s2 = e2.getBoundingClientRect() : e2 instanceof SVGElement && (s2 = t2.target_element.getBBox()), "left" === t2.position && (this.parent.style.left = s2.x + (s2.width + 10) + "px", this.parent.style.top = s2.y + "px", this.pointer.style.transform = "rotateZ(90deg)", this.pointer.style.left = "-7px", this.pointer.style.top = "2px"), this.parent.style.opacity = 1;
    }
    hide() {
      this.parent.style.opacity = 0;
    }
  }
  return class {
    constructor(t2, e2, s2) {
      this.setup_wrapper(t2), this.setup_options(s2), this.setup_tasks(e2), this.change_view_mode(), this.bind_events();
    }
    setup_wrapper(t2) {
      let e2, s2;
      if ("string" == typeof t2 && (t2 = document.querySelector(t2)), t2 instanceof HTMLElement)
        s2 = t2, e2 = t2.querySelector("svg");
      else {
        if (!(t2 instanceof SVGElement))
          throw new TypeError("Frappé Gantt only supports usage of a string CSS selector, HTML DOM element or SVG DOM element for the 'element' parameter");
        e2 = t2;
      }
      e2 ? (this.$svg = e2, this.$svg.classList.add("gantt")) : this.$svg = n("svg", { append_to: s2, class: "gantt" }), this.$container = document.createElement("div"), this.$container.classList.add("gantt-container"), this.$svg.parentElement.appendChild(this.$container), this.$container.appendChild(this.$svg), this.popup_wrapper = document.createElement("div"), this.popup_wrapper.classList.add("popup-wrapper"), this.$container.appendChild(this.popup_wrapper);
    }
    setup_options(t2) {
      this.options = Object.assign({}, { header_height: 50, column_width: 30, step: 24, view_modes: ["Quarter Day", "Half Day", "Day", "Week", "Month", "Year"], bar_height: 20, bar_corner_radius: 3, arrow_curve: 5, padding: 18, view_mode: "Day", date_format: "YYYY-MM-DD", popup_trigger: "click", custom_popup_html: null, language: "en" }, t2);
    }
    setup_tasks(t2) {
      this.tasks = t2.map((t3, s2) => {
        if (t3._start = e.parse(t3.start), t3._end = e.parse(t3.end), e.diff(t3._end, t3._start, "year") > 10 && (t3.end = null), t3._index = s2, !t3.start && !t3.end) {
          const s3 = e.today();
          t3._start = s3, t3._end = e.add(s3, 2, "day");
        }
        if (!t3.start && t3.end && (t3._start = e.add(t3._end, -2, "day")), t3.start && !t3.end && (t3._end = e.add(t3._start, 2, "day")), e.get_date_values(t3._end).slice(3).every((t4) => 0 === t4) && (t3._end = e.add(t3._end, 24, "hour")), t3.start && t3.end || (t3.invalid = true), "string" == typeof t3.dependencies || !t3.dependencies) {
          let e2 = [];
          t3.dependencies && (e2 = t3.dependencies.split(",").map((t4) => t4.trim()).filter((t4) => t4)), t3.dependencies = e2;
        }
        return t3.id || (t3.id = function(t4) {
          return t4.name + "_" + Math.random().toString(36).slice(2, 12);
        }(t3)), t3;
      }), this.setup_dependencies();
    }
    setup_dependencies() {
      this.dependency_map = {};
      for (let t2 of this.tasks)
        for (let e2 of t2.dependencies)
          this.dependency_map[e2] = this.dependency_map[e2] || [], this.dependency_map[e2].push(t2.id);
    }
    refresh(t2) {
      this.setup_tasks(t2), this.change_view_mode();
    }
    change_view_mode(t2 = this.options.view_mode) {
      this.update_view_scale(t2), this.setup_dates(), this.render(), this.trigger_event("view_change", [t2]);
    }
    update_view_scale(t2) {
      this.options.view_mode = t2, "Day" === t2 ? (this.options.step = 24, this.options.column_width = 38) : "Half Day" === t2 ? (this.options.step = 12, this.options.column_width = 38) : "Quarter Day" === t2 ? (this.options.step = 6, this.options.column_width = 38) : "Week" === t2 ? (this.options.step = 168, this.options.column_width = 140) : "Month" === t2 ? (this.options.step = 720, this.options.column_width = 120) : "Year" === t2 && (this.options.step = 8760, this.options.column_width = 120);
    }
    setup_dates() {
      this.setup_gantt_dates(), this.setup_date_values();
    }
    setup_gantt_dates() {
      this.gantt_start = this.gantt_end = null;
      for (let t2 of this.tasks)
        (!this.gantt_start || t2._start < this.gantt_start) && (this.gantt_start = t2._start), (!this.gantt_end || t2._end > this.gantt_end) && (this.gantt_end = t2._end);
      this.gantt_start = e.start_of(this.gantt_start, "day"), this.gantt_end = e.start_of(this.gantt_end, "day"), this.view_is(["Quarter Day", "Half Day"]) ? (this.gantt_start = e.add(this.gantt_start, -7, "day"), this.gantt_end = e.add(this.gantt_end, 7, "day")) : this.view_is("Month") ? (this.gantt_start = e.start_of(this.gantt_start, "year"), this.gantt_end = e.add(this.gantt_end, 1, "year")) : this.view_is("Year") ? (this.gantt_start = e.add(this.gantt_start, -2, "year"), this.gantt_end = e.add(this.gantt_end, 2, "year")) : (this.gantt_start = e.add(this.gantt_start, -1, "month"), this.gantt_end = e.add(this.gantt_end, 1, "month"));
    }
    setup_date_values() {
      this.dates = [];
      let t2 = null;
      for (; null === t2 || t2 < this.gantt_end; )
        t2 = t2 ? this.view_is("Year") ? e.add(t2, 1, "year") : this.view_is("Month") ? e.add(t2, 1, "month") : e.add(t2, this.options.step, "hour") : e.clone(this.gantt_start), this.dates.push(t2);
    }
    bind_events() {
      this.bind_grid_click(), this.bind_bar_events();
    }
    render() {
      this.clear(), this.setup_layers(), this.make_grid(), this.make_dates(), this.make_bars(), this.make_arrows(), this.map_arrows_on_bars(), this.set_width(), this.set_scroll_position();
    }
    setup_layers() {
      this.layers = {};
      const t2 = ["grid", "date", "arrow", "progress", "bar", "details"];
      for (let e2 of t2)
        this.layers[e2] = n("g", { class: e2, append_to: this.$svg });
    }
    make_grid() {
      this.make_grid_background(), this.make_grid_rows(), this.make_grid_header(), this.make_grid_ticks(), this.make_grid_highlights();
    }
    make_grid_background() {
      const t2 = this.dates.length * this.options.column_width, e2 = this.options.header_height + this.options.padding + (this.options.bar_height + this.options.padding) * this.tasks.length;
      n("rect", { x: 0, y: 0, width: t2, height: e2, class: "grid-background", append_to: this.layers.grid }), i.attr(this.$svg, { height: e2 + this.options.padding + 100, width: "100%" });
    }
    make_grid_rows() {
      const t2 = n("g", { append_to: this.layers.grid }), e2 = n("g", { append_to: this.layers.grid }), s2 = this.dates.length * this.options.column_width, i2 = this.options.bar_height + this.options.padding;
      let a2 = this.options.header_height + this.options.padding / 2;
      for (let o2 of this.tasks)
        n("rect", { x: 0, y: a2, width: s2, height: i2, class: "grid-row", append_to: t2 }), n("line", { x1: 0, y1: a2 + i2, x2: s2, y2: a2 + i2, class: "row-line", append_to: e2 }), a2 += this.options.bar_height + this.options.padding;
    }
    make_grid_header() {
      n("rect", { x: 0, y: 0, width: this.dates.length * this.options.column_width, height: this.options.header_height + 10, class: "grid-header", append_to: this.layers.grid });
    }
    make_grid_ticks() {
      let t2 = 0, s2 = this.options.header_height + this.options.padding / 2, i2 = (this.options.bar_height + this.options.padding) * this.tasks.length;
      for (let a2 of this.dates) {
        let o2 = "tick";
        this.view_is("Day") && 1 === a2.getDate() && (o2 += " thick"), this.view_is("Week") && a2.getDate() >= 1 && a2.getDate() < 8 && (o2 += " thick"), this.view_is("Month") && (a2.getMonth() + 1) % 3 == 0 && (o2 += " thick"), n("path", { d: `M ${t2} ${s2} v ${i2}`, class: o2, append_to: this.layers.grid }), this.view_is("Month") ? t2 += e.get_days_in_month(a2) * this.options.column_width / 30 : t2 += this.options.column_width;
      }
    }
    make_grid_highlights() {
      this.view_is("Day") && n("rect", { x: e.diff(e.today(), this.gantt_start, "hour") / this.options.step * this.options.column_width, y: 0, width: this.options.column_width, height: (this.options.bar_height + this.options.padding) * this.tasks.length + this.options.header_height + this.options.padding / 2, class: "today-highlight", append_to: this.layers.grid });
    }
    make_dates() {
      for (let t2 of this.get_dates_to_draw())
        if (n("text", { x: t2.lower_x, y: t2.lower_y, innerHTML: t2.lower_text, class: "lower-text", append_to: this.layers.date }), t2.upper_text) {
          const e2 = n("text", { x: t2.upper_x, y: t2.upper_y, innerHTML: t2.upper_text, class: "upper-text", append_to: this.layers.date });
          e2.getBBox().x2 > this.layers.grid.getBBox().width && e2.remove();
        }
    }
    get_dates_to_draw() {
      let t2 = null;
      return this.dates.map((e2, s2) => {
        const i2 = this.get_date_info(e2, t2, s2);
        return t2 = e2, i2;
      });
    }
    get_date_info(t2, s2, i2) {
      s2 || (s2 = e.add(t2, 1, "year"));
      const n2 = { "Quarter Day_lower": e.format(t2, "HH", this.options.language), "Half Day_lower": e.format(t2, "HH", this.options.language), Day_lower: t2.getDate() !== s2.getDate() ? e.format(t2, "D", this.options.language) : "", Week_lower: t2.getMonth() !== s2.getMonth() ? e.format(t2, "D MMM", this.options.language) : e.format(t2, "D", this.options.language), Month_lower: e.format(t2, "MMMM", this.options.language), Year_lower: e.format(t2, "YYYY", this.options.language), "Quarter Day_upper": t2.getDate() !== s2.getDate() ? e.format(t2, "D MMM", this.options.language) : "", "Half Day_upper": t2.getDate() !== s2.getDate() ? t2.getMonth() !== s2.getMonth() ? e.format(t2, "D MMM", this.options.language) : e.format(t2, "D", this.options.language) : "", Day_upper: t2.getMonth() !== s2.getMonth() ? e.format(t2, "MMMM", this.options.language) : "", Week_upper: t2.getMonth() !== s2.getMonth() ? e.format(t2, "MMMM", this.options.language) : "", Month_upper: t2.getFullYear() !== s2.getFullYear() ? e.format(t2, "YYYY", this.options.language) : "", Year_upper: t2.getFullYear() !== s2.getFullYear() ? e.format(t2, "YYYY", this.options.language) : "" }, a2 = { x: i2 * this.options.column_width, lower_y: this.options.header_height, upper_y: this.options.header_height - 25 }, o2 = { "Quarter Day_lower": 4 * this.options.column_width / 2, "Quarter Day_upper": 0, "Half Day_lower": 2 * this.options.column_width / 2, "Half Day_upper": 0, Day_lower: this.options.column_width / 2, Day_upper: 30 * this.options.column_width / 2, Week_lower: 0, Week_upper: 4 * this.options.column_width / 2, Month_lower: this.options.column_width / 2, Month_upper: 12 * this.options.column_width / 2, Year_lower: this.options.column_width / 2, Year_upper: 30 * this.options.column_width / 2 };
      return { upper_text: n2[`${this.options.view_mode}_upper`], lower_text: n2[`${this.options.view_mode}_lower`], upper_x: a2.x + o2[`${this.options.view_mode}_upper`], upper_y: a2.upper_y, lower_x: a2.x + o2[`${this.options.view_mode}_lower`], lower_y: a2.lower_y };
    }
    make_bars() {
      this.bars = this.tasks.map((t2) => {
        const e2 = new o(this, t2);
        return this.layers.bar.appendChild(e2.group), e2;
      });
    }
    make_arrows() {
      this.arrows = [];
      for (let t2 of this.tasks) {
        let e2 = [];
        e2 = t2.dependencies.map((e3) => {
          const s2 = this.get_task(e3);
          if (!s2)
            return;
          const i2 = new r(this, this.bars[s2._index], this.bars[t2._index]);
          return this.layers.arrow.appendChild(i2.element), i2;
        }).filter(Boolean), this.arrows = this.arrows.concat(e2);
      }
    }
    map_arrows_on_bars() {
      for (let t2 of this.bars)
        t2.arrows = this.arrows.filter((e2) => e2.from_task.task.id === t2.task.id || e2.to_task.task.id === t2.task.id);
    }
    set_width() {
      const t2 = this.$svg.getBoundingClientRect().width, e2 = this.$svg.querySelector(".grid .grid-row").getAttribute("width");
      t2 < e2 && this.$svg.setAttribute("width", e2);
    }
    set_scroll_position() {
      const t2 = this.$svg.parentElement;
      if (!t2)
        return;
      const s2 = e.diff(this.get_oldest_starting_date(), this.gantt_start, "hour") / this.options.step * this.options.column_width - this.options.column_width;
      t2.scrollLeft = s2;
    }
    bind_grid_click() {
      i.on(this.$svg, this.options.popup_trigger, ".grid-row, .grid-header", () => {
        this.unselect_all(), this.hide_popup();
      });
    }
    bind_bar_events() {
      let t2 = false, e2 = 0, s2 = 0, n2 = false, a2 = false, o2 = null, r2 = [];
      this.bar_being_dragged = null, i.on(this.$svg, "mousedown", ".bar-wrapper, .handle", (h2, d) => {
        const p = i.closest(".bar-wrapper", d);
        d.classList.contains("left") ? n2 = true : d.classList.contains("right") ? a2 = true : d.classList.contains("bar-wrapper") && (t2 = true), p.classList.add("active"), e2 = h2.offsetX, s2 = h2.offsetY;
        const _ = [o2 = p.getAttribute("data-id"), ...this.get_all_dependent_tasks(o2)];
        r2 = _.map((t3) => this.get_bar(t3)), this.bar_being_dragged = o2, r2.forEach((t3) => {
          const e3 = t3.$bar;
          e3.ox = e3.getX(), e3.oy = e3.getY(), e3.owidth = e3.getWidth(), e3.finaldx = 0;
        });
      }), i.on(this.$svg, "mousemove", (s3) => {
        if (!(t2 || n2 || a2))
          return;
        const i2 = s3.offsetX - e2;
        s3.offsetY, r2.forEach((e3) => {
          const s4 = e3.$bar;
          s4.finaldx = this.get_snap_position(i2), n2 ? o2 === e3.task.id ? e3.update_bar_position({ x: s4.ox + s4.finaldx, width: s4.owidth - s4.finaldx }) : e3.update_bar_position({ x: s4.ox + s4.finaldx }) : a2 ? o2 === e3.task.id && e3.update_bar_position({ width: s4.owidth + s4.finaldx }) : t2 && e3.update_bar_position({ x: s4.ox + s4.finaldx });
        });
      }), document.addEventListener("mouseup", (e3) => {
        (t2 || n2 || a2) && r2.forEach((t3) => t3.group.classList.remove("active")), t2 = false, n2 = false, a2 = false;
      }), i.on(this.$svg, "mouseup", (t3) => {
        this.bar_being_dragged = null, r2.forEach((t4) => {
          t4.$bar.finaldx && (t4.date_changed(), t4.set_action_completed());
        });
      }), this.bind_bar_progress();
    }
    bind_bar_progress() {
      let t2 = 0, e2 = 0, s2 = null, n2 = null, a2 = null, o2 = null;
      i.on(this.$svg, "mousedown", ".handle.progress", (r2, h2) => {
        s2 = true, t2 = r2.offsetX, e2 = r2.offsetY;
        const d = i.closest(".bar-wrapper", h2).getAttribute("data-id");
        n2 = this.get_bar(d), a2 = n2.$bar_progress, o2 = n2.$bar, a2.finaldx = 0, a2.owidth = a2.getWidth(), a2.min_dx = -a2.getWidth(), a2.max_dx = o2.getWidth() - a2.getWidth();
      }), i.on(this.$svg, "mousemove", (e3) => {
        if (!s2)
          return;
        let o3 = e3.offsetX - t2;
        e3.offsetY, o3 > a2.max_dx && (o3 = a2.max_dx), o3 < a2.min_dx && (o3 = a2.min_dx);
        const r2 = n2.$handle_progress;
        i.attr(a2, "width", a2.owidth + o3), i.attr(r2, "points", n2.get_progress_polygon_points()), a2.finaldx = o3;
      }), i.on(this.$svg, "mouseup", () => {
        s2 = false, a2 && a2.finaldx && (n2.progress_changed(), n2.set_action_completed());
      });
    }
    get_all_dependent_tasks(t2) {
      let e2 = [], s2 = [t2];
      for (; s2.length; ) {
        const t3 = s2.reduce((t4, e3) => t4 = t4.concat(this.dependency_map[e3]), []);
        e2 = e2.concat(t3), s2 = t3.filter((t4) => !s2.includes(t4));
      }
      return e2.filter(Boolean);
    }
    get_snap_position(t2) {
      let e2, s2, i2 = t2;
      return s2 = this.view_is("Week") ? i2 - (e2 = t2 % (this.options.column_width / 7)) + (e2 < this.options.column_width / 14 ? 0 : this.options.column_width / 7) : this.view_is("Month") ? i2 - (e2 = t2 % (this.options.column_width / 30)) + (e2 < this.options.column_width / 60 ? 0 : this.options.column_width / 30) : i2 - (e2 = t2 % this.options.column_width) + (e2 < this.options.column_width / 2 ? 0 : this.options.column_width);
    }
    unselect_all() {
      [...this.$svg.querySelectorAll(".bar-wrapper")].forEach((t2) => {
        t2.classList.remove("active");
      });
    }
    view_is(t2) {
      return "string" == typeof t2 ? this.options.view_mode === t2 : !!Array.isArray(t2) && t2.some((t3) => this.options.view_mode === t3);
    }
    get_task(t2) {
      return this.tasks.find((e2) => e2.id === t2);
    }
    get_bar(t2) {
      return this.bars.find((e2) => e2.task.id === t2);
    }
    show_popup(t2) {
      this.popup || (this.popup = new h(this.popup_wrapper, this.options.custom_popup_html)), this.popup.show(t2);
    }
    hide_popup() {
      this.popup && this.popup.hide();
    }
    trigger_event(t2, e2) {
      this.options["on_" + t2] && this.options["on_" + t2].apply(null, e2);
    }
    get_oldest_starting_date() {
      return this.tasks.map((t2) => t2._start).reduce((t2, e2) => e2 <= t2 ? e2 : t2);
    }
    clear() {
      this.$svg.innerHTML = "";
    }
  };
}();
//# sourceMappingURL=frappe-gantt_dist_frappe-gantt__min__js.js.map
